{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"DuFuzzyLogic A Fuzzy Logic Implementation DuFuzzyLogic What is Fuzzy Logic? JavaScript Implementation After Effects Expressions Implementation What is Fuzzy Logic? Fuzzy Logic is a way to replace Boolean logic when values may not be completely true or false, e.g. a temperature can be hot, but more precisely it can be just a bit hot or very hot. Using Fuzzy Logic is a way to test the veracity of a statement, and get a nuanced result, which can then be used to set nuanced values according to the truthness, the veracity, obtained from the statement. For example, if one wants to adjust the power of a fan, he needs to check the temperature and adjust the fan accordingly. With boolean logic, the statement IF the temperature IS hot THEN SET the fan on will either turn the fan on at full power or completely off, according to a predefined limit value. With Fuzzy Logic, both the veracity and the result being fuzzy and more nuanced, the same statement will adjust precisely the power of the fan according to the hotness. With a single simple rule like this, it is like a conversion (interpolation) of the temperature value into a power value. - Read more about Fuzzy Logic JavaScript Implementation For now, this is an implementation of Fuzzy Logic for JavaScript, but I plan to implement it the same way in Qt/C++, Python, and probably C# for Unity. The source is available in this repo . Everything is fully documented . The code is fully compatible with Adobe ExtendScript too. The implementation creates 4 new classes: FuzzyLogic is the main class, the logic engine. FuzzySet represents fuzzy sets. FuzzyValue represents fuzzy values. FuzzyVeracity represents the veracity used in the rules instead of booleans. This implementation uses fluent syntax for the logic, thus operators are methods of the FuzzyVeracity class which return FuzzyVeracity instances. Here is an example of a rule in this fluent syntax which result is stored in a variable: var isRed = redChannel.IS( intense ) .AND( greenChannel.IS( intense ). NOR( blueChannel.IS( intense )) ) In this example, isRed is an instance of FuzzyVeracity ; redChannel , greenChannel , blueChannel are FuzzyValues and intense is a FuzzySet It is the equivalent of the boolean logi: var isRed = redChannel == intense !( greenChannel == intense || blueChannel == intenst ) - Read the reference for all the details. After Effects Expressions Implementation The implementation of the same library but adapted for expressions in After Effects (some changes have been made for better compatibility with both the extendscript and the javascript engine) is available as part of the DuAEF Expression Library .","title":"Home"},{"location":"index.html#dufuzzylogic","text":"A Fuzzy Logic Implementation DuFuzzyLogic What is Fuzzy Logic? JavaScript Implementation After Effects Expressions Implementation","title":"DuFuzzyLogic"},{"location":"index.html#what-is-fuzzy-logic","text":"Fuzzy Logic is a way to replace Boolean logic when values may not be completely true or false, e.g. a temperature can be hot, but more precisely it can be just a bit hot or very hot. Using Fuzzy Logic is a way to test the veracity of a statement, and get a nuanced result, which can then be used to set nuanced values according to the truthness, the veracity, obtained from the statement. For example, if one wants to adjust the power of a fan, he needs to check the temperature and adjust the fan accordingly. With boolean logic, the statement IF the temperature IS hot THEN SET the fan on will either turn the fan on at full power or completely off, according to a predefined limit value. With Fuzzy Logic, both the veracity and the result being fuzzy and more nuanced, the same statement will adjust precisely the power of the fan according to the hotness. With a single simple rule like this, it is like a conversion (interpolation) of the temperature value into a power value. - Read more about Fuzzy Logic","title":"What is Fuzzy Logic?"},{"location":"index.html#javascript-implementation","text":"For now, this is an implementation of Fuzzy Logic for JavaScript, but I plan to implement it the same way in Qt/C++, Python, and probably C# for Unity. The source is available in this repo . Everything is fully documented . The code is fully compatible with Adobe ExtendScript too. The implementation creates 4 new classes: FuzzyLogic is the main class, the logic engine. FuzzySet represents fuzzy sets. FuzzyValue represents fuzzy values. FuzzyVeracity represents the veracity used in the rules instead of booleans. This implementation uses fluent syntax for the logic, thus operators are methods of the FuzzyVeracity class which return FuzzyVeracity instances. Here is an example of a rule in this fluent syntax which result is stored in a variable: var isRed = redChannel.IS( intense ) .AND( greenChannel.IS( intense ). NOR( blueChannel.IS( intense )) ) In this example, isRed is an instance of FuzzyVeracity ; redChannel , greenChannel , blueChannel are FuzzyValues and intense is a FuzzySet It is the equivalent of the boolean logi: var isRed = redChannel == intense !( greenChannel == intense || blueChannel == intenst ) - Read the reference for all the details.","title":"JavaScript Implementation"},{"location":"index.html#after-effects-expressions-implementation","text":"The implementation of the same library but adapted for expressions in After Effects (some changes have been made for better compatibility with both the extendscript and the javascript engine) is available as part of the DuAEF Expression Library .","title":"After Effects Expressions Implementation"},{"location":"Advantages.html","text":"Advantages These rules are very intuitive and very easy to use , as the implementation of the logic can be very close to natural language . For that matter, it seems Fuzzy Logic are much closer to how we actually reason, think, and make deductions in every day life than simple Boolean logic with only yes or no answers; life is analogical, not binary, and so are our thoughts. You will also notice that there is no need for the Else word anymore, and that combining a lot of rules makes a system both very resilient and precise. Thus, when a lot of rules are used, Fuzzy Logic is very resistant to mistakes, oversights or imprecision . Note that this resilience can be a problem when trying to improve the system, as it becomes quickly difficult to understand the effect of each individual rule. When implementing Fuzzy Logic, it is very useful to have access to the result of each individual rules . Principle Concretely, there are three important steps to use Fuzzy Logic, from getting some input variables to generating output values. Input variables are crisp values, so the first step is to turn them into fuzzy values which can be quantified, and thus used in conditions and rules. Let s call this Fuzzification . Rules have to be defined to control output values. This is the actual Logic step. Results have to be converted back from fuzzy values, the output of the rules, to actual crisp values. This can be called De-Fuzzification or Crispification .","title":"Advantages"},{"location":"Advantages.html#advantages","text":"These rules are very intuitive and very easy to use , as the implementation of the logic can be very close to natural language . For that matter, it seems Fuzzy Logic are much closer to how we actually reason, think, and make deductions in every day life than simple Boolean logic with only yes or no answers; life is analogical, not binary, and so are our thoughts. You will also notice that there is no need for the Else word anymore, and that combining a lot of rules makes a system both very resilient and precise. Thus, when a lot of rules are used, Fuzzy Logic is very resistant to mistakes, oversights or imprecision . Note that this resilience can be a problem when trying to improve the system, as it becomes quickly difficult to understand the effect of each individual rule. When implementing Fuzzy Logic, it is very useful to have access to the result of each individual rules .","title":"Advantages"},{"location":"Advantages.html#principle","text":"Concretely, there are three important steps to use Fuzzy Logic, from getting some input variables to generating output values. Input variables are crisp values, so the first step is to turn them into fuzzy values which can be quantified, and thus used in conditions and rules. Let s call this Fuzzification . Rules have to be defined to control output values. This is the actual Logic step. Results have to be converted back from fuzzy values, the output of the rules, to actual crisp values. This can be called De-Fuzzification or Crispification .","title":"Principle"},{"location":"AirConditioning.html","text":"Air conditioning Air conditioning 1 - Setup 2 - Values 3 - Rules 4 - Results This is a comprehensive example meant to show how to use multiple sets and rules to control a (fake) air conditioning system. Here s how this system is supposed to work, based on measured temperature (in \u00b0C ) and humidity in the air (in % ). The system is controlled by a power parameter in the range [-100%, 100%]. When it is negative, it cools down the room, when it is positive, it heats it up. The system takes the humidity into account. Let s say when the air is humid, we feel colder or hotter, so we need the system to run at a higher - or lower if it cooling - power. With the same reasoning, when the air is dry, we want to lower the power consumption (because it s better for the planet). This system is designed to show how using Fuzzy Logic makes things simpler in the code, but it is unnecessarily complex. For example in real life, it would not be the same value which controls both heating and cooling, and the rules would be a bit simpler. 1 - Setup First things firts, let s create the engine. var logic = new FuzzyLogic( FuzzyLogicAlgorithm.HYPERBOLIC ); The parameter changes the algorithm used for logic rules. It is optionnal, and slightly changes the behaviour of the system. Now we can create the sets. This is the most important part, the parameters used in the sets will have a big impact on the results. We can see these values as the settings of the air conditionning system. Humidity: // Too wet is more than 70%, completely wet is 100%. Constant shape above 100%: it's still too wet! var wet = logic.newSet( Wet , 60, 100, FuzzyShape.GAUSSIAN, FuzzyShape.CONSTANT); // The comfort zone begins at 40%, and its most comfortable at 60%. We use the same shape above and below this comfort zone. var comfortable = logic.newSet( Comfortable , 40, 55, FuzzyShape.SIGMOID); // Too dry is less than 50%, completely dry is 0%. Constant shape under 0%: it's still too dry! var dry = logic.newSet( Dry , 50, 0, FuzzyShape.CONSTANT, FuzzyShape.GAUSSIAN); Temperature: // Temperature // The principle is the same than humidity. var hot = logic.newSet( Hot , 21, 35, FuzzyShape.GAUSSIAN, FuzzyShape.CONSTANT); var warm = logic.newSet( Comfortably warm , 17, 20, FuzzyShape.GAUSSIAN); var cold = logic.newSet( Cold , 17, 10, FuzzyShape.CONSTANT, FuzzyShape.GAUSSIAN); Heating, ventilation and air-conditioning power: // Let's say a positive power (from 0% to 100%) heats the room, a negative one cools it. var heat = logic.newSet( Heat , 0, 100, FuzzyShape.LINEAR, FuzzyShape.CONSTANT); var refresh = logic.newSet( Refresh , 0, -100, FuzzyShape.CONSTANT, FuzzyShape.LINEAR); 2 - Values Input Values: We have two input values. These are what is going to vary, the result of the sensors. // Change these values to test the engine var temperature = logic.newValue( 20, \u00b0C ); var humidity = logic.newValue( 50 , % ); Output Value: There is one output value, which is the power of the air conditionning system. var hvacPower = logic.newValue( 0, % ); // Enable reports to be able to have a look at the result of the logic hvacPower.reportEnabled = true; 3 - Rules This is the fun part, just write some rules! The easy ones first. // If it's hot, let's cool down logic.IF( temperature.IS( hot ) ); logic.THEN( hvacPower, refresh ); // Rule #1 // If it's cold, let's heat up logic.IF( temperature.IS( cold ) ); logic.THEN( hvacPower, heat ); // Rule #2 But we want to adjust depending on the humidity. The (fake) idea is that if it s too humid, we need more power (because we feel less comfortable?). // If it's hot and wet, we want to refresh more logic.IF( temperature.IS( hot) .AND ( humidity.IS( wet ) ) ); logic.THEN( hvacPower, refresh, More ); // Rule #3 // If it's cold and wet, we want to heat more logic.IF( temperature.IS(cold) .AND ( humidity.IS( wet ) ) ); logic.THEN( hvacPower, heat, More ); // Rule #4 If it's dry, we lower the power (because we don't want the hvac to make the air even drier) // If it's cold but not too cold and it is dry, we want to heat less to save energy logic.IF( temperature.IS(cold) .AND ( temperature.IS_NOT( cold, Extremely ) ) .AND ( humidity.IS( dry ) ) ); logic.THEN( hvacPower, heat, Less ); // Rule #5 // If it's hot but not too hot, and it is dry, we want to refresh less to save energy logic.IF( temperature.IS( hot ) .AND ( temperature.IS_NOT( hot, Extremely ) ) .AND ( humidity.IS( dry ) ) ); logic.THEN( hvacPower, refresh, Less ); // Rule #6 And if it s really comfortably warm or cold, but wet, let s raise the temperature a lil bit more logic.IF( temperature.IS( warm, very ) .OR ( temperature.IS(cold) ) .AND ( humidity.IS( wet ) ) ) logic.THEN( hvacPower, heat, Somewhat ); // Rule #7 Of course, if it s just comfortable, we want to stop the hvac. logic.IF( temperature.IS( warm ) ); logic.THEN( hvacPower, heat, not ); // Rule #8 logic.THEN( hvacPower, refresh, not ); // Rule #9 4 - Results The Print() in this example can be replaced by any method which shows/prints a string. // Print the result Print( temperature.toString( hot ) + and + temperature.toString( cold ) ); Print( humidity.toString(wet) + and + humidity.toString( dry ) ); Print( ); Print( temperature.toString( warm ) ); Print( humidity.toString( comfortable ) ); Print( ); Print( RESULT: the power of the air conditionner is + hvacPower.toString() ); Print( ); Print( This is how this result is obtained: ) for (var i = 0, num = hvacPower.report.length; i num; i++) { Print( ); Print( hvacPower.report[i].join( br / ) ); } This is what will be printed with 25\u00b0C and 75% humidity. 25\u00b0C is Somewhat Hot and 25\u00b0C is Not Cold 75% is Somewhat Wet and 75% is Not Dry 25\u00b0C is Not Comfortably warm 75% is Not Comfortable RESULT: the power of the air conditionner is -47.51% This is how this result is obtained: Rule #1: Set Refresh (Moderately) Gives value: -23.303 from these values: [ -23.303 ] With a veracity of: 0.243 Rule #2: Set Heat (Moderately) Gives value: 0 from these values: [ 0 ] With a veracity of: 0 Rule #3: Set Refresh (More) Gives value: -119.8 from these values: [ -100, -100, -100, -200, -99 ] With a veracity of: 0.082 Rule #4: Set Heat (More) Gives value: 120 from these values: [ 100, 100, 100, 100, 200 ] With a veracity of: 0 Rule #5: Set Heat (Less) Gives value: 0 from these values: [ 0 ] With a veracity of: 0 Rule #6: Set Refresh (Less) Gives value: 0 from these values: [ 0 ] With a veracity of: 0 Rule #7: Set Heat (Somewhat) Gives value: 0 from these values: [ 0 ] With a veracity of: 0 Rule #9: Set Refresh (Not) Gives value: 0 from these values: [ 0 ] With a veracity of: 0 Rule #9: Set Heat (Not) Gives value: 0 from these values: [ 0 ] With a veracity of: 0 You can also compare different crispification algorithms quite easily: // The default is CENTROID Print( RESULT CENTROID: the power of the air conditionner is + hvacPower.toString() ); Print( RESULT CENTROID_LOWER: the power of the air conditionner is + hvacPower.toString(FuzzyCrispAlgorithm.CENTROID_LOWER) ); Print( RESULT CENTROID_HIGHER: the power of the air conditionner is + hvacPower.toString(FuzzyCrispAlgorithm.CENTROID_HIGHER) ); Print( RESULT MEAN: the power of the air conditionner is + hvacPower.toString(FuzzyCrispAlgorithm.MEAN) ); Print( RESULT MEAN_HIGHER: the power of the air conditionner is + hvacPower.toString(FuzzyCrispAlgorithm.MEAN_HIGHER) ); Print( RESULT MEAN_LOWER: the power of the air conditionner is + hvacPower.toString(FuzzyCrispAlgorithm.MEAN_LOWER) ); // Note that you can also globally set the algorithm as a second argument when creating the engine: var lowerLogic = new FuzzyLogic( FuzzyLogicAlgorithm.LINEAR, FuzzyCrispAlgorithm.CENTROID_LOWER); // The default for crispification will be the one passed to this engine Which will print: RESULT CENTROID: the power of the air conditionner is -47.51% RESULT CENTROID_LOWER: the power of the air conditionner is -67.71% RESULT CENTROID_HIGHER: the power of the air conditionner is -42.27% RESULT MEAN: the power of the air conditionner is -2.57% RESULT MEAN_HIGHER: the power of the air conditionner is 8.63% RESULT MEAN_LOWER: the power of the air conditionner is -13.7%","title":"HVAC Complex example"},{"location":"AirConditioning.html#air-conditioning","text":"Air conditioning 1 - Setup 2 - Values 3 - Rules 4 - Results This is a comprehensive example meant to show how to use multiple sets and rules to control a (fake) air conditioning system. Here s how this system is supposed to work, based on measured temperature (in \u00b0C ) and humidity in the air (in % ). The system is controlled by a power parameter in the range [-100%, 100%]. When it is negative, it cools down the room, when it is positive, it heats it up. The system takes the humidity into account. Let s say when the air is humid, we feel colder or hotter, so we need the system to run at a higher - or lower if it cooling - power. With the same reasoning, when the air is dry, we want to lower the power consumption (because it s better for the planet). This system is designed to show how using Fuzzy Logic makes things simpler in the code, but it is unnecessarily complex. For example in real life, it would not be the same value which controls both heating and cooling, and the rules would be a bit simpler.","title":"Air conditioning"},{"location":"AirConditioning.html#1-setup","text":"First things firts, let s create the engine. var logic = new FuzzyLogic( FuzzyLogicAlgorithm.HYPERBOLIC ); The parameter changes the algorithm used for logic rules. It is optionnal, and slightly changes the behaviour of the system. Now we can create the sets. This is the most important part, the parameters used in the sets will have a big impact on the results. We can see these values as the settings of the air conditionning system. Humidity: // Too wet is more than 70%, completely wet is 100%. Constant shape above 100%: it's still too wet! var wet = logic.newSet( Wet , 60, 100, FuzzyShape.GAUSSIAN, FuzzyShape.CONSTANT); // The comfort zone begins at 40%, and its most comfortable at 60%. We use the same shape above and below this comfort zone. var comfortable = logic.newSet( Comfortable , 40, 55, FuzzyShape.SIGMOID); // Too dry is less than 50%, completely dry is 0%. Constant shape under 0%: it's still too dry! var dry = logic.newSet( Dry , 50, 0, FuzzyShape.CONSTANT, FuzzyShape.GAUSSIAN); Temperature: // Temperature // The principle is the same than humidity. var hot = logic.newSet( Hot , 21, 35, FuzzyShape.GAUSSIAN, FuzzyShape.CONSTANT); var warm = logic.newSet( Comfortably warm , 17, 20, FuzzyShape.GAUSSIAN); var cold = logic.newSet( Cold , 17, 10, FuzzyShape.CONSTANT, FuzzyShape.GAUSSIAN); Heating, ventilation and air-conditioning power: // Let's say a positive power (from 0% to 100%) heats the room, a negative one cools it. var heat = logic.newSet( Heat , 0, 100, FuzzyShape.LINEAR, FuzzyShape.CONSTANT); var refresh = logic.newSet( Refresh , 0, -100, FuzzyShape.CONSTANT, FuzzyShape.LINEAR);","title":"1 - Setup"},{"location":"AirConditioning.html#2-values","text":"Input Values: We have two input values. These are what is going to vary, the result of the sensors. // Change these values to test the engine var temperature = logic.newValue( 20, \u00b0C ); var humidity = logic.newValue( 50 , % ); Output Value: There is one output value, which is the power of the air conditionning system. var hvacPower = logic.newValue( 0, % ); // Enable reports to be able to have a look at the result of the logic hvacPower.reportEnabled = true;","title":"2 - Values"},{"location":"AirConditioning.html#3-rules","text":"This is the fun part, just write some rules! The easy ones first. // If it's hot, let's cool down logic.IF( temperature.IS( hot ) ); logic.THEN( hvacPower, refresh ); // Rule #1 // If it's cold, let's heat up logic.IF( temperature.IS( cold ) ); logic.THEN( hvacPower, heat ); // Rule #2 But we want to adjust depending on the humidity. The (fake) idea is that if it s too humid, we need more power (because we feel less comfortable?). // If it's hot and wet, we want to refresh more logic.IF( temperature.IS( hot) .AND ( humidity.IS( wet ) ) ); logic.THEN( hvacPower, refresh, More ); // Rule #3 // If it's cold and wet, we want to heat more logic.IF( temperature.IS(cold) .AND ( humidity.IS( wet ) ) ); logic.THEN( hvacPower, heat, More ); // Rule #4 If it's dry, we lower the power (because we don't want the hvac to make the air even drier) // If it's cold but not too cold and it is dry, we want to heat less to save energy logic.IF( temperature.IS(cold) .AND ( temperature.IS_NOT( cold, Extremely ) ) .AND ( humidity.IS( dry ) ) ); logic.THEN( hvacPower, heat, Less ); // Rule #5 // If it's hot but not too hot, and it is dry, we want to refresh less to save energy logic.IF( temperature.IS( hot ) .AND ( temperature.IS_NOT( hot, Extremely ) ) .AND ( humidity.IS( dry ) ) ); logic.THEN( hvacPower, refresh, Less ); // Rule #6 And if it s really comfortably warm or cold, but wet, let s raise the temperature a lil bit more logic.IF( temperature.IS( warm, very ) .OR ( temperature.IS(cold) ) .AND ( humidity.IS( wet ) ) ) logic.THEN( hvacPower, heat, Somewhat ); // Rule #7 Of course, if it s just comfortable, we want to stop the hvac. logic.IF( temperature.IS( warm ) ); logic.THEN( hvacPower, heat, not ); // Rule #8 logic.THEN( hvacPower, refresh, not ); // Rule #9","title":"3 - Rules"},{"location":"AirConditioning.html#4-results","text":"The Print() in this example can be replaced by any method which shows/prints a string. // Print the result Print( temperature.toString( hot ) + and + temperature.toString( cold ) ); Print( humidity.toString(wet) + and + humidity.toString( dry ) ); Print( ); Print( temperature.toString( warm ) ); Print( humidity.toString( comfortable ) ); Print( ); Print( RESULT: the power of the air conditionner is + hvacPower.toString() ); Print( ); Print( This is how this result is obtained: ) for (var i = 0, num = hvacPower.report.length; i num; i++) { Print( ); Print( hvacPower.report[i].join( br / ) ); } This is what will be printed with 25\u00b0C and 75% humidity. 25\u00b0C is Somewhat Hot and 25\u00b0C is Not Cold 75% is Somewhat Wet and 75% is Not Dry 25\u00b0C is Not Comfortably warm 75% is Not Comfortable RESULT: the power of the air conditionner is -47.51% This is how this result is obtained: Rule #1: Set Refresh (Moderately) Gives value: -23.303 from these values: [ -23.303 ] With a veracity of: 0.243 Rule #2: Set Heat (Moderately) Gives value: 0 from these values: [ 0 ] With a veracity of: 0 Rule #3: Set Refresh (More) Gives value: -119.8 from these values: [ -100, -100, -100, -200, -99 ] With a veracity of: 0.082 Rule #4: Set Heat (More) Gives value: 120 from these values: [ 100, 100, 100, 100, 200 ] With a veracity of: 0 Rule #5: Set Heat (Less) Gives value: 0 from these values: [ 0 ] With a veracity of: 0 Rule #6: Set Refresh (Less) Gives value: 0 from these values: [ 0 ] With a veracity of: 0 Rule #7: Set Heat (Somewhat) Gives value: 0 from these values: [ 0 ] With a veracity of: 0 Rule #9: Set Refresh (Not) Gives value: 0 from these values: [ 0 ] With a veracity of: 0 Rule #9: Set Heat (Not) Gives value: 0 from these values: [ 0 ] With a veracity of: 0 You can also compare different crispification algorithms quite easily: // The default is CENTROID Print( RESULT CENTROID: the power of the air conditionner is + hvacPower.toString() ); Print( RESULT CENTROID_LOWER: the power of the air conditionner is + hvacPower.toString(FuzzyCrispAlgorithm.CENTROID_LOWER) ); Print( RESULT CENTROID_HIGHER: the power of the air conditionner is + hvacPower.toString(FuzzyCrispAlgorithm.CENTROID_HIGHER) ); Print( RESULT MEAN: the power of the air conditionner is + hvacPower.toString(FuzzyCrispAlgorithm.MEAN) ); Print( RESULT MEAN_HIGHER: the power of the air conditionner is + hvacPower.toString(FuzzyCrispAlgorithm.MEAN_HIGHER) ); Print( RESULT MEAN_LOWER: the power of the air conditionner is + hvacPower.toString(FuzzyCrispAlgorithm.MEAN_LOWER) ); // Note that you can also globally set the algorithm as a second argument when creating the engine: var lowerLogic = new FuzzyLogic( FuzzyLogicAlgorithm.LINEAR, FuzzyCrispAlgorithm.CENTROID_LOWER); // The default for crispification will be the one passed to this engine Which will print: RESULT CENTROID: the power of the air conditionner is -47.51% RESULT CENTROID_LOWER: the power of the air conditionner is -67.71% RESULT CENTROID_HIGHER: the power of the air conditionner is -42.27% RESULT MEAN: the power of the air conditionner is -2.57% RESULT MEAN_HIGHER: the power of the air conditionner is 8.63% RESULT MEAN_LOWER: the power of the air conditionner is -13.7%","title":"4 - Results"},{"location":"Crispification.html","text":"Crispification When the rules have been applied and have output some fuzzy value, the last step is to get back some crisp values to use in the system. Intuitively, one could think that it s just a matter of getting the average of all the results of all the rules, depending on the veracities of each statement. But depending on the shape of the sets, there can be several values with the same veracity. In this case, the centroid algorithm is the most used, which consists in getting all possible values from the set for the given veracity of each statement, and getting the mean of these values. Then all the single values resulting from each statement can be averaged, weighted by their veracity. Variations can be made on this algorithm, to keep only the higher values or discard them for example, which would either raise or lower a bit the final result, or by returning a range instead of a single value which the system can then use as best fits. Other algorithms could be implemented for crispification, for example one could also get a random or pseudo-random value from all possible values.","title":"Crispification"},{"location":"Crispification.html#crispification","text":"When the rules have been applied and have output some fuzzy value, the last step is to get back some crisp values to use in the system. Intuitively, one could think that it s just a matter of getting the average of all the results of all the rules, depending on the veracities of each statement. But depending on the shape of the sets, there can be several values with the same veracity. In this case, the centroid algorithm is the most used, which consists in getting all possible values from the set for the given veracity of each statement, and getting the mean of these values. Then all the single values resulting from each statement can be averaged, weighted by their veracity. Variations can be made on this algorithm, to keep only the higher values or discard them for example, which would either raise or lower a bit the final result, or by returning a range instead of a single value which the system can then use as best fits. Other algorithms could be implemented for crispification, for example one could also get a random or pseudo-random value from all possible values.","title":"Crispification"},{"location":"Examples.html","text":"Examples Here are some examples using a JavaScript implementation of Fuzzy Logic. JavaScript: Color: Evaluate Redness Complex example: HVAC control","title":"Examples"},{"location":"Examples.html#examples","text":"Here are some examples using a JavaScript implementation of Fuzzy Logic. JavaScript: Color: Evaluate Redness Complex example: HVAC control","title":"Examples"},{"location":"Fuzzification.html","text":"Fuzzification Fuzzification Sets Operators: IS and IS NOT Fuzzification is the process of getting a precise, crisp value which could be used in Boolean Logic (comparing it to other values), and turning it into a fuzzy value, i.e. a quantified value compared to a set (or several sets) of values. For example, let s take the speed of a car. 87kmph is a crisp value. With Fuzzy Logic, we are not going to compare it to other crisp values, but we want to quantify it, i.e. be able to answer these questions: Is it fast? Is it slow? The answer being fuzzy too and not simply true or false - we are not going to just say that this speed is fast because it is more than 50kmph, we need to quantify how fast it is. In this case, what we need to do is define what fast and slow mean to be able to answer the question. And fast and slow are not single values, they are sets of values which are more or less fast and slow . Fuzzification is just that: defining sets of values. Sets A set of values associates to every single value a truthiness or veracity which defines how much the value is included in the set. Usually, this veracity is implemented as a value in the range [0, 1] where 0 means the value is not at all in the set, and 1 that the value is exactly what the set defines. Back to the speed example, fast can be all values which are higher than 50kmph, 250kmph being the fastest one, while slow may represent values under 50kmph, the slowest one being 0kmph. As you can see, sets can overlap, and it is actually better if they overlap to be able to precisely quantify any crisp value. 45kmph is at once just a little bit fast and slightly slow. Operators: IS and IS NOT This defines the Fuzzy operators IS and IS NOT : they are the operators which get the veracity of a crisp value in a given set, like in the statement IF 87kmph IS fast or IF 87kmph IS slow or IF 87kmph IS NOT slow They check the inclusion of the value in the given set.","title":"Fuzzification"},{"location":"Fuzzification.html#fuzzification","text":"Fuzzification Sets Operators: IS and IS NOT Fuzzification is the process of getting a precise, crisp value which could be used in Boolean Logic (comparing it to other values), and turning it into a fuzzy value, i.e. a quantified value compared to a set (or several sets) of values. For example, let s take the speed of a car. 87kmph is a crisp value. With Fuzzy Logic, we are not going to compare it to other crisp values, but we want to quantify it, i.e. be able to answer these questions: Is it fast? Is it slow? The answer being fuzzy too and not simply true or false - we are not going to just say that this speed is fast because it is more than 50kmph, we need to quantify how fast it is. In this case, what we need to do is define what fast and slow mean to be able to answer the question. And fast and slow are not single values, they are sets of values which are more or less fast and slow . Fuzzification is just that: defining sets of values.","title":"Fuzzification"},{"location":"Fuzzification.html#sets","text":"A set of values associates to every single value a truthiness or veracity which defines how much the value is included in the set. Usually, this veracity is implemented as a value in the range [0, 1] where 0 means the value is not at all in the set, and 1 that the value is exactly what the set defines. Back to the speed example, fast can be all values which are higher than 50kmph, 250kmph being the fastest one, while slow may represent values under 50kmph, the slowest one being 0kmph. As you can see, sets can overlap, and it is actually better if they overlap to be able to precisely quantify any crisp value. 45kmph is at once just a little bit fast and slightly slow.","title":"Sets"},{"location":"Fuzzification.html#operators-is-and-is-not","text":"This defines the Fuzzy operators IS and IS NOT : they are the operators which get the veracity of a crisp value in a given set, like in the statement IF 87kmph IS fast or IF 87kmph IS slow or IF 87kmph IS NOT slow They check the inclusion of the value in the given set.","title":"Operators: IS and IS NOT"},{"location":"Home.html","text":"Fuzzy Logic Introduction Advantages Principle Fuzzification Sets Operators: IS and IS NOT Shapes Common shapes and membership functions Combining shapes Rules and logic operators Operators Implementation Quantifiers Condition quantifiers A Game of words Linguistic Newspeak Symbolic Crispification Examples JavaScript: Color: Redness JavaScript: Complex example: HVAC Existing Libraries Introduction to Fuzzy Logic Fuzzy Logic is a way to replace Boolean logic when values may not be completely true or false, e.g. a temperature can be hot, but more precisely it can be just a bit hot or very hot. Using Fuzzy Logic is a way to test the veracity of a statement, and get a nuanced result, which can then be used to set nuanced values according to the truthness, the veracity, obtained from the statement. For example, if one wants to adjust the power of a fan, one needs to check the temperature and adjust the fan accordingly. With boolean logic, the statement IF the temperature IS hot THEN SET the fan on will either turn the fan on at full power or completely off, according to a predefined limit value. With Fuzzy Logic, both the veracity and the result being fuzzy and more nuanced, the same statement will adjust precisely the power of the fan according to the hotness. With a single simple rule like this, it is like a conversion (interpolation) of the temperature value into a power value. But like Boolean logic, Fuzzy Logic becomes very interesting when combining veracity and rules. For example, it becomes easy to code a program with these rules: IF the temperature IS hot THEN SET the fan on and SET the heater off IF the temperature IS warm THEN SET the fan off and SET the heater off IF the temperature IS cold THEN SET the fan off and SET the heater on And if you combine other conditions and quantifiers, you can design quite a complex system: IF temperature IS hot AND humidity is high THEN SET fan top speed IF temperature IS hot AND humidity is VERY low THEN SET fan moderate speed etc. This logic can be used (and is used) in a lot of different domains and situation. Think about all kind of controls, auto-pilots, AI, animation","title":"Introduction"},{"location":"Home.html#fuzzy-logic","text":"Introduction Advantages Principle Fuzzification Sets Operators: IS and IS NOT Shapes Common shapes and membership functions Combining shapes Rules and logic operators Operators Implementation Quantifiers Condition quantifiers A Game of words Linguistic Newspeak Symbolic Crispification Examples JavaScript: Color: Redness JavaScript: Complex example: HVAC Existing Libraries","title":"Fuzzy Logic"},{"location":"Home.html#introduction-to-fuzzy-logic","text":"Fuzzy Logic is a way to replace Boolean logic when values may not be completely true or false, e.g. a temperature can be hot, but more precisely it can be just a bit hot or very hot. Using Fuzzy Logic is a way to test the veracity of a statement, and get a nuanced result, which can then be used to set nuanced values according to the truthness, the veracity, obtained from the statement. For example, if one wants to adjust the power of a fan, one needs to check the temperature and adjust the fan accordingly. With boolean logic, the statement IF the temperature IS hot THEN SET the fan on will either turn the fan on at full power or completely off, according to a predefined limit value. With Fuzzy Logic, both the veracity and the result being fuzzy and more nuanced, the same statement will adjust precisely the power of the fan according to the hotness. With a single simple rule like this, it is like a conversion (interpolation) of the temperature value into a power value. But like Boolean logic, Fuzzy Logic becomes very interesting when combining veracity and rules. For example, it becomes easy to code a program with these rules: IF the temperature IS hot THEN SET the fan on and SET the heater off IF the temperature IS warm THEN SET the fan off and SET the heater off IF the temperature IS cold THEN SET the fan off and SET the heater on And if you combine other conditions and quantifiers, you can design quite a complex system: IF temperature IS hot AND humidity is high THEN SET fan top speed IF temperature IS hot AND humidity is VERY low THEN SET fan moderate speed etc. This logic can be used (and is used) in a lot of different domains and situation. Think about all kind of controls, auto-pilots, AI, animation","title":"Introduction to Fuzzy Logic"},{"location":"Libraries.html","text":"Libraries JS DuFuzzyLogic https://github.com/sebs/es6-fuzz https://github.com/marcolanaro/JS-Fuzzy Adobe After Effects Expressions DuAEF Expression Library C++ http://www.fuzzylite.com/cpp/","title":"Existing Libraries"},{"location":"Libraries.html#libraries","text":"JS DuFuzzyLogic https://github.com/sebs/es6-fuzz https://github.com/marcolanaro/JS-Fuzzy Adobe After Effects Expressions DuAEF Expression Library C++ http://www.fuzzylite.com/cpp/","title":"Libraries"},{"location":"Quantifiers.html","text":"Quantifiers Quantifiers Condition quantifiers A Game of words Linguistic Newlinguistic - Orwellian (Newspeak) Symbolic To improve the precision of the rules, we can use quantifiers, i.e. instead of just checking IF temperature IS hot we could check IF temperature IS *VERY* hot or IF temperature IS *SLIGHTLY* hot . Quantifiers are mostly used when checking the inclusion of a value in a set (i.e. the veracity of a propostion like IF anything IS VERY something ), but they can also be used for setting a value (e.g. in the statement THEN SET something VERY anything ) Condition quantifiers Quantifiers could also be useful to adjust the global veracity of a statement instead of the veracity of each operand. For example, the statement IF temperature IS SOMEWHAT hot AND humidity IS SOMEWHAT high could become MAYBE temperature IS hot AND humidity IS high . In this case a possible list of these quantified conditions could be: If, Probably, Maybe, Somewhat, Not A Game of words Depending on the implementation of Fuzzy Logic, there may be several ways to represent quantifiers. They could be a value, for example varying in a [0, 1] range from just a bit to extremely . Or they may be linguistic, actual words, to keep the language intuitive and easy to use and understand, close to natural language. Linguistic quantifiers are also easier to differenciate from veracities which can also be reprensented as values in the range [0, 1] and could be easily confused with them. As veracities need to be precise, they need to be actual numbers. On the contrary, quantifiers do not need that precision and can be represented by a carefully chosen set of words. In case of linguistic quantifiers, the choice of the words to use is importanat: their interpretation will influence how they are used when coding with Fuzzy Logic. There can be three ways of defining linguistic quantifiers, to make them both easy to use and remember, and more or less precise or subtle: Linguistic : actual words (English, or any other language) with their true meaning. Newlinguistic or Orwellian : neologisms, like those Orwell describres in his newspeak in the novel 1984 , created to simplify natural language and make it both less subtle and more objective. Symbolic : adjectives from natural language, but used differently than their true meanings, like the some properties of quantic particles, for example the color charges - red, green, blue, antigreen, antiblue, antired - or the flavors of quarks - strange, charm, bottom, top - which obviously do not really describe any color or strangeness. Linguistic As one goal of programming with Fuzzy Logic is to keep it simple and natural, using actual language and the linguistic version of quantifiers would be best, as they make the most intuitive and subtle possible. But with all the ambiguity and subjectiveness of language, this is quite a very difficult task to implement, unless each quantifier is precisely described in the documentation. Which makes it paradoxically a bit counter-intuitive. A possible list of English quantifiers could be (in this order ?): Not, least, a bit, lesser, less than, quite (UK), rather, fairly, more or less, average, quite (US), very, extremely, almost, completely Newlinguistic - Orwellian (Newspeak) Orwellian Newspaak makes things easier while keeping the vocabulary user-friendly even if it is - by design - less subtle and more abstract. Newspeak quantifiers are a composite of the word Plus or Minus with a multiplier, to which we can add Not , Average and Completely , which gives us this list: Not, tripleminus, doubleminus, minus, average, plus, doubleplus, tripleplus, completely . And this list can be expanded at will. Symbolic Symbolic quantifiers are another way to abstractify the words describing quantifiers, while keeping them easy to use and remember. They could be adjectives which could be more or less intuitively sorted, like bright and dark or light and heavy , but it may be difficult to build a list long enough to allow the precision needed with some systems. One could combine different meanings and arbitrarily sort them to have a list like this: Not, gaseous, light, liquid, fluid, floppy, solid, hard, heavy Or one could use alphabetically sorted adjectives: able, bad, cool, dark Or even adjectives sorted by their number of letters: Not, cool, green, purple, abstract, objective For systems which do not need too many quantifiers and thus too many words to remember, this method can actually be useful and funny to use.","title":"Quantifiers"},{"location":"Quantifiers.html#quantifiers","text":"Quantifiers Condition quantifiers A Game of words Linguistic Newlinguistic - Orwellian (Newspeak) Symbolic To improve the precision of the rules, we can use quantifiers, i.e. instead of just checking IF temperature IS hot we could check IF temperature IS *VERY* hot or IF temperature IS *SLIGHTLY* hot . Quantifiers are mostly used when checking the inclusion of a value in a set (i.e. the veracity of a propostion like IF anything IS VERY something ), but they can also be used for setting a value (e.g. in the statement THEN SET something VERY anything )","title":"Quantifiers"},{"location":"Quantifiers.html#condition-quantifiers","text":"Quantifiers could also be useful to adjust the global veracity of a statement instead of the veracity of each operand. For example, the statement IF temperature IS SOMEWHAT hot AND humidity IS SOMEWHAT high could become MAYBE temperature IS hot AND humidity IS high . In this case a possible list of these quantified conditions could be: If, Probably, Maybe, Somewhat, Not","title":"Condition quantifiers"},{"location":"Quantifiers.html#a-game-of-words","text":"Depending on the implementation of Fuzzy Logic, there may be several ways to represent quantifiers. They could be a value, for example varying in a [0, 1] range from just a bit to extremely . Or they may be linguistic, actual words, to keep the language intuitive and easy to use and understand, close to natural language. Linguistic quantifiers are also easier to differenciate from veracities which can also be reprensented as values in the range [0, 1] and could be easily confused with them. As veracities need to be precise, they need to be actual numbers. On the contrary, quantifiers do not need that precision and can be represented by a carefully chosen set of words. In case of linguistic quantifiers, the choice of the words to use is importanat: their interpretation will influence how they are used when coding with Fuzzy Logic. There can be three ways of defining linguistic quantifiers, to make them both easy to use and remember, and more or less precise or subtle: Linguistic : actual words (English, or any other language) with their true meaning. Newlinguistic or Orwellian : neologisms, like those Orwell describres in his newspeak in the novel 1984 , created to simplify natural language and make it both less subtle and more objective. Symbolic : adjectives from natural language, but used differently than their true meanings, like the some properties of quantic particles, for example the color charges - red, green, blue, antigreen, antiblue, antired - or the flavors of quarks - strange, charm, bottom, top - which obviously do not really describe any color or strangeness.","title":"A Game of words"},{"location":"Quantifiers.html#linguistic","text":"As one goal of programming with Fuzzy Logic is to keep it simple and natural, using actual language and the linguistic version of quantifiers would be best, as they make the most intuitive and subtle possible. But with all the ambiguity and subjectiveness of language, this is quite a very difficult task to implement, unless each quantifier is precisely described in the documentation. Which makes it paradoxically a bit counter-intuitive. A possible list of English quantifiers could be (in this order ?): Not, least, a bit, lesser, less than, quite (UK), rather, fairly, more or less, average, quite (US), very, extremely, almost, completely","title":"Linguistic"},{"location":"Quantifiers.html#newlinguistic-orwellian-newspeak","text":"Orwellian Newspaak makes things easier while keeping the vocabulary user-friendly even if it is - by design - less subtle and more abstract. Newspeak quantifiers are a composite of the word Plus or Minus with a multiplier, to which we can add Not , Average and Completely , which gives us this list: Not, tripleminus, doubleminus, minus, average, plus, doubleplus, tripleplus, completely . And this list can be expanded at will.","title":"Newlinguistic - Orwellian (Newspeak)"},{"location":"Quantifiers.html#symbolic","text":"Symbolic quantifiers are another way to abstractify the words describing quantifiers, while keeping them easy to use and remember. They could be adjectives which could be more or less intuitively sorted, like bright and dark or light and heavy , but it may be difficult to build a list long enough to allow the precision needed with some systems. One could combine different meanings and arbitrarily sort them to have a list like this: Not, gaseous, light, liquid, fluid, floppy, solid, hard, heavy Or one could use alphabetically sorted adjectives: able, bad, cool, dark Or even adjectives sorted by their number of letters: Not, cool, green, purple, abstract, objective For systems which do not need too many quantifiers and thus too many words to remember, this method can actually be useful and funny to use.","title":"Symbolic"},{"location":"Redness.html","text":"Color: Evaluate Redness // Setup var logic = new FuzzyLogic(); // We don't need to worry about values above 255 var intense = logic.newSet( Intense , 0, 255); // The color to test var color = [255,200,10]; // A value to store the result var redness = logic.newValue(); // Separate channels var redChannel = logic.newValue( color[0] ); var greenChannel = logic.newValue( color[1] ); var blueChannel = logic.newValue( color[2] ); logic.IF( redChannel.IS( intense ) .AND( greenChannel.IS( intense ). NOR( blueChannel.IS( intense )) ) ) logic.THEN( redness, intense ); // Print the result Print( [ + color.toString() + ] is + redness.quantify( intense ).toString() + Red ); This is what is printed: [255,200,10] is Somewhat Red","title":"Color Redness"},{"location":"Redness.html#color-evaluate-redness","text":"// Setup var logic = new FuzzyLogic(); // We don't need to worry about values above 255 var intense = logic.newSet( Intense , 0, 255); // The color to test var color = [255,200,10]; // A value to store the result var redness = logic.newValue(); // Separate channels var redChannel = logic.newValue( color[0] ); var greenChannel = logic.newValue( color[1] ); var blueChannel = logic.newValue( color[2] ); logic.IF( redChannel.IS( intense ) .AND( greenChannel.IS( intense ). NOR( blueChannel.IS( intense )) ) ) logic.THEN( redness, intense ); // Print the result Print( [ + color.toString() + ] is + redness.quantify( intense ).toString() + Red ); This is what is printed: [255,200,10] is Somewhat Red","title":"Color: Evaluate Redness"},{"location":"Rules.html","text":"Rules Rules are defined by operators, like AND , OR , EQUALS , etc. While it is easy to understand what these operators do in Boolean Logic, with Fuzzy Logic there are several ways of defining and implementing them, as the result of IF the temperature IS hot AND the temperature IS comfortable is neither true or false , but a veracity in the range [0, 1]. Wikipedia has a nice List of operators with representations of them to easily compare the algorithms. Implementation With the veracity x , y and the weight w in the range [0,1] for fuzzy logic, and x,y,w = 0 or 1 for boolean logic. Name JavaScript, C Boolean Python Boolean Fuzzy: Zadeh (linear) Fuzzy: Hyperbolic Parabloid Fuzzy: Yager-2 NOT(x) !x not x 1-x 1-x 1-x AND(x,y) x y x and y min(x,y) xy 1- min( 1, sqrt( (1-x)\u00b2 + (1-y)\u00b2 ) ) OR(x,y) x || y x or y max(x,y) x+y - xy min( 1, (x\u00b2 + y\u00b2)\u00b2 ) XOR(x,y) x != y x is not y x + y - 2min(x,y) x+y - 2xy NXR(x,y) x == y x is y 1-x-y + 2*min(x,y) 1-x-y + (2xy) IMPLIES(x,y) !(x !y) not (x and not y) 1 - min(x, 1-y) 1 - x + xy DOES_NOT_IMPLY(x,y) x !y x and not y min(x,1-y) x*(1-y) NAND(x,y) !(x y) not (x and y) 1-min(x,y) 1 - xy NOR(x,y) !(x || y) not (x or y) 1 - max(x,y) 1-x-y + xy WEIGHTED(x,y,w wx + (1-w)y wx + (1-w)y wx + (1-w)y","title":"Logic operators"},{"location":"Rules.html#rules","text":"Rules are defined by operators, like AND , OR , EQUALS , etc. While it is easy to understand what these operators do in Boolean Logic, with Fuzzy Logic there are several ways of defining and implementing them, as the result of IF the temperature IS hot AND the temperature IS comfortable is neither true or false , but a veracity in the range [0, 1]. Wikipedia has a nice List of operators with representations of them to easily compare the algorithms.","title":"Rules"},{"location":"Rules.html#implementation","text":"With the veracity x , y and the weight w in the range [0,1] for fuzzy logic, and x,y,w = 0 or 1 for boolean logic. Name JavaScript, C Boolean Python Boolean Fuzzy: Zadeh (linear) Fuzzy: Hyperbolic Parabloid Fuzzy: Yager-2 NOT(x) !x not x 1-x 1-x 1-x AND(x,y) x y x and y min(x,y) xy 1- min( 1, sqrt( (1-x)\u00b2 + (1-y)\u00b2 ) ) OR(x,y) x || y x or y max(x,y) x+y - xy min( 1, (x\u00b2 + y\u00b2)\u00b2 ) XOR(x,y) x != y x is not y x + y - 2min(x,y) x+y - 2xy NXR(x,y) x == y x is y 1-x-y + 2*min(x,y) 1-x-y + (2xy) IMPLIES(x,y) !(x !y) not (x and not y) 1 - min(x, 1-y) 1 - x + xy DOES_NOT_IMPLY(x,y) x !y x and not y min(x,1-y) x*(1-y) NAND(x,y) !(x y) not (x and y) 1-min(x,y) 1 - xy NOR(x,y) !(x || y) not (x or y) 1 - max(x,y) 1-x-y + xy WEIGHTED(x,y,w wx + (1-w)y wx + (1-w)y wx + (1-w)y","title":"Implementation"},{"location":"Shapes.html","text":"Shapes Shapes Common shapes and membership functions Combining shapes Now comes the question of how does the veracity transition to is not in the set (0 or false) to is in the set (1 or true). The most intuitive is that the transition may be linear, i.e. if a set starts at 0 up to 100, the crisp value 50 has a veracity of 0.5 and the crisp value 25 has a veracity of 0.25 . This set can be represented by a graph where the values are on the horizontal axis and the veracity is on the vertical axis: Its shape is linear. It may be interesting to change the shape of the set, to better reflect what the value represents or what it may be used for. The shape of the set is given by a membership function. It is a function which takes any given value as variable and which result is the veracity of the inclusion of this value in the set, a.k.a its membership. Membership functions can be any function and generate any kind of shape. Common shapes and membership functions IF value limit THEN veracity IS 1 ELSE veracity is 0 A simple linear function An S-shaped function, which can be the standard logistic function An bell-shaped function, which is the gaussian function The bell-shaped function may be useful in its reversed form too. It is also possible to use a B\u00e9zier curve to define a parametric shape, or any other function. Note that a given crisp value can be above or below a set. For example, 0\u2070C is not in the set comfortable , neither is 50\u2070C. In this case, the comfortable set can have a shape with two sides: It is also possible to have a plateau where all values are equally (and indifferentially) in the set, or true. Combining shapes Combining several shapes, it is possible to represent any crisp value from -inifinity to +infinity. This reasoning is for 1-dimensionnal sets, but we could imagine 2 or 3-D sets, which would be represented by a fuzzy area or a fuzzy volume, allowing to quantify 2-D or 3-D values or vectors. And it is also possible to build n-dimension sets to test n-dimension values (e.g. an RGB color with Alpha which is 4D) but the more dimensions, the more complex the functions for defining the shapes are.","title":"Shapes"},{"location":"Shapes.html#shapes","text":"Shapes Common shapes and membership functions Combining shapes Now comes the question of how does the veracity transition to is not in the set (0 or false) to is in the set (1 or true). The most intuitive is that the transition may be linear, i.e. if a set starts at 0 up to 100, the crisp value 50 has a veracity of 0.5 and the crisp value 25 has a veracity of 0.25 . This set can be represented by a graph where the values are on the horizontal axis and the veracity is on the vertical axis: Its shape is linear. It may be interesting to change the shape of the set, to better reflect what the value represents or what it may be used for. The shape of the set is given by a membership function. It is a function which takes any given value as variable and which result is the veracity of the inclusion of this value in the set, a.k.a its membership. Membership functions can be any function and generate any kind of shape.","title":"Shapes"},{"location":"Shapes.html#common-shapes-and-membership-functions","text":"IF value limit THEN veracity IS 1 ELSE veracity is 0 A simple linear function An S-shaped function, which can be the standard logistic function An bell-shaped function, which is the gaussian function The bell-shaped function may be useful in its reversed form too. It is also possible to use a B\u00e9zier curve to define a parametric shape, or any other function. Note that a given crisp value can be above or below a set. For example, 0\u2070C is not in the set comfortable , neither is 50\u2070C. In this case, the comfortable set can have a shape with two sides: It is also possible to have a plateau where all values are equally (and indifferentially) in the set, or true.","title":"Common shapes and membership functions"},{"location":"Shapes.html#combining-shapes","text":"Combining several shapes, it is possible to represent any crisp value from -inifinity to +infinity. This reasoning is for 1-dimensionnal sets, but we could imagine 2 or 3-D sets, which would be represented by a fuzzy area or a fuzzy volume, allowing to quantify 2-D or 3-D values or vectors. And it is also possible to build n-dimension sets to test n-dimension values (e.g. an RGB color with Alpha which is 4D) but the more dimensions, the more complex the functions for defining the shapes are.","title":"Combining shapes"}]}